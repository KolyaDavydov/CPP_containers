TO DO
епс из дефайне

подумать, нужно ли дописать остальные инсерты, эрайз


КОММЕНТАРИИ
В случае, если оригинальный метод дает уб или сег фолт, максимально старалась повторить это поведение
в деструкторе нет очищения lSize, capacity. Тесты на деструктор напрямую написать нельзя, так как в данном случае дважды почиститься память

[] нет проверки границ - в тестах так же этих кейсов проверки - тогда упал бы сег фолт или уб
at есть проверка границ - выброс exception

front(), back() - нет проверки на пустоту массива - в тестах так же этих кейсов проверки - тогда упал бы сег фолт или уб. Во front() и back() оставила vArr[], т.к. at будет выкидывать exception, а у оригинала уб
reserve() не работает с константными векторами. В reverse() используется std::move()
shrink_to_fit() - используется std::move()
reserve() и shrink_to_fit() - по сути своей две противоположные операции

итераторы:
data() - для нулевого вектора уб
begin(), end() - - для нулевого вектора уб (но не сег фолт как в листах). Но при нулевом они будут показывать на одно место
data() предпочтительно использовать, чтобы указать куда-то, а begin() - для итерации

модификаторы:
все модификаторы не работают на константных векторах
insert: интересно, что если высчитывать индекс после reserve(), индекс м.б. неправильным, так как массив м.б. перенесен в другое место
std_vec.insert(std_vec.end() + 2, 30); // вызовет сег фолт
std_vec.erase(std_vec.begin()); // вызовет сег фолт //нельзя удалять что то из пустого массива
вызов pop_back пустого массива вызовет сег фолт - поэтому и мы у себя не будем проверять на ноль и повторим их сег фолт