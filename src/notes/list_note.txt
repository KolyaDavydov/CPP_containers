TO DO:
почистить все пуши от комментариев в push, pop

пока в splice не const_iterator, а iterator - оставила пока так, ибо не вижу в этом смысла

КОММЕНТАРИИ

разыменовывание end() по сути приводит к уб (в моем случае к сег фолту). Я пока смогла сделать на этот момент exception,
так как фактически у нас зацикленная система и разыменование carbineNode покажет значение по адресу этого фейкого
элемента (а там лежит дефолтное значение этого типа). На nulptr можно не проверять, так как у нас при инициализации
сразу и carbineNode, и его next, prev - carbineNode. Соответственно, даже в пустом массиве мы все равно будем разыименовывать carbineNode


front() пустого листа дает уб - так как в оригинале нет проверки на пустой лист и у нас ее нет. В тестах у нас нет кейсов с пустым листом - во избежание падения или уб
 в итераторе согласно редми мы реализуем только префиксный инкремент

переделаy lSize() в  приватную переменную, так как доступ к ней должен быть за О(1), т.е. константна
lSize() в листе реализован не через begin(), end(), так как для этого в классах итераторов нужно еще реализовывать минус
в названии функции оставила size(), а не lSize(), во-первых, потому что внутри lSize, во-вторых, потому что так в оригинале, и третье - для лучшей читаемости

по сути любое добавление элемента - это сначала мы устанавливаем next, prev самого элемента, а потом ставим для каких элементов он сам будет next и prev

erase не проверяет нулевой лист или нет. В случае нулевого массива - уб, size() улетает в небеса

empty() проверяет carbineNode == carbineNode->next, так как эта ситуация может быть только при пустом листе, например при инициализации. При этом это не гарантирует что, size() == 0

ПРИСВАИВАНИЕ С ПЕРЕМЕЩЕНИЕМ при самом себе приводит к уб!!!!!!!!! Also, the standard library functions called with
xvalue arguments may assume the argument is the only reference to the object; if it was constructed from an lvalue
with std::move, no aliasing checks are made. However, self-move-assignment of standard library types is guaranteed to p
lace the object in a valid (but usually unspecified) state.
https://en.cppreference.com/w/cpp/utility/move

НО!!! swap для самого себя проходит нормально!

merge работает только с ОТСОРТИРОВАННЫМИ СПИСКАМИ, иначе уб!!!!

unique удаляет ТОЛЬКО ПОСЛЕДОВАТЕЛЬНО ПОВТОРЯЮЩИЕСЯ элементы, оставляя первый. т.е. из 1 1 2 он удалит серединный 1. Но из 1 2 1 2 он не удалит вторые 1 и 2

нельзя делать splice самого в себя - внутри себе получается фактически повторяющийся бесконечный цикл из значений листа. Такой тест писать нельзя!!! При том, так как в оригинале нет защиты-проверки самого себя, то и у нас ее не будет